
-- Timed
local totalTimeToCollect = 120
local timeToCollectLeft
local dmgTimeLosPenelty = 20
-- 


-- Player

local player
local playerStartingLives = 3
local playerTimesHit = 0
local PlayerCoins
playerIsDead = true
--
local gameActive = false

local level_heights = { 35, 280, 500 }
local level_heights_recipients = {
	"/hero#hero"
}

local def_objekt_spawn_cooldown = 3
local def_objekt_spawn_cooldown_add = 3

local def_move_speed = 5
local coin_spawn_cooldown = 0
local coin_spawn_interval = 4

local spike_spawn_cooldown = 5

local star_spawn_cooldown = 2

local gameTime = 0
local spikeSpawnExponentialIncrease = 0.05

local gamemode
local difficulty

function init(self)

	timeToCollectLeft = totalTimeToCollect
	-- Hämtar fönstrets bredd och höjd
	local width, height = window.get_size()
	
	
	
	msg.post(".", "acquire_input_focus")
	--print("HJJJJJJJJJJJJJJJJJJJJJJJJJ")
	local text_url = msg.url("/text_holder#GameOver") -- URL till textkomponenten
	go.set(text_url, "color.w", 0) -- Sätter alfa (w) till 0 för att göra den osynlig
	-- Skicka meddelandet till alla mottagare
	for _, recipient in ipairs(level_heights_recipients) do
		--msg.post(recipient, "set_level_heights", { heights = level_heights })
	end
	msg.post("/level/ground/controller_ground#ground", "set_speed", { speed = def_move_speed })
	--print(def_move_speed)
	factory.create("#runner_platform_factory",  vmath.vector3(0, level_heights[2], 0), nil, {}, 0.5)
	factory.create("#runner_platform_factory",  vmath.vector3(0, level_heights[3], 0), nil, {}, 0.5)
	local m = factory.create("/game_maneger#menu_factory", vmath.vector3(width / 2 ,(height / 2) + 20, 1), nil, {}, 1)
	
end
function final(self)
	-- Return input focus when the object is deleted
	msg.post(".", "release_input_focus")
end
function update(self, dt)
	
	
		star_spawn_cooldown = star_spawn_cooldown -dt



		
		if star_spawn_cooldown < 0 then
			local hs = level_heights[math.random(#level_heights)]
			hs = hs + math.random(10, 100)
			local new_objekt = factory.create("#star_factory",  vmath.vector3(1600, hs, 0), nil, {}, 0.5)
			msg.post(new_objekt, "set_speed", { speed = math.random(3, 6) })

			local random_rotation = math.random() * 360  -- Slumpmässig rotation mellan 0 och 360 grader
			--print(random_rotation)
			local random_rotation_rad = math.rad(random_rotation)  -- Omvandla till radianer
			go.set(new_objekt, "rotation", vmath.quat_rotation_z(random_rotation_rad))
			go.set_scale(math.random(1, 1.8), new_objekt)


			star_spawn_cooldown = math.random(4, 8)

		end

		if  gameActive then
			gameTime = gameTime + dt
			timeToCollectLeft = timeToCollectLeft - dt
			UpdateTimmer(self)
			def_objekt_spawn_cooldown = def_objekt_spawn_cooldown -dt
			--if def_objekt_spawn_cooldown < 0 then
			coin_spawn_cooldown = coin_spawn_cooldown - dt
			spike_spawn_cooldown = spike_spawn_cooldown - dt
			if coin_spawn_cooldown < 0 then
				local h = level_heights[math.random(#level_heights)]
				--print("hhhhhhh    " ..h)
				local new_coin = factory.create("#coin_factory",  vmath.vector3(1600, h, 0), nil, {}, 0.5)
				msg.post(new_coin, "set_speed", { speed = def_move_speed })
				coin_spawn_cooldown = coin_spawn_interval
				def_objekt_spawn_cooldown = def_objekt_spawn_cooldown_add

			end
			if spike_spawn_cooldown < 0 then
				local ha = level_heights[math.random(#level_heights)]
				--print("hhhhhhh    " ..h)
				local new_spike = factory.create("#spike_factory",  vmath.vector3(1600, ha, 0), nil, {}, 0.5)
				msg.post(new_spike, "set_speed", { speed = def_move_speed })
				local cooldown =  7 * math.exp(-spikeSpawnExponentialIncrease * gameTime)
				if cooldown < 1 then
					cooldown = 1
				end
				spike_spawn_cooldown = cooldown
				print("C:   "..cooldown)
				def_objekt_spawn_cooldown = def_objekt_spawn_cooldown_add

			end
		end

		
		--end

		
	

end

function PlayerTakeDmg(self)
	
	if gamemode == "Endless" then
		-- Hämta aktuell text från labeln
		local current_text = label.get_text("/text_holder#Coins")
		local current_coins = tonumber(string.match(current_text, "%d+")) or 0
		-- Extrahera nuvarande antal mynt från texten (om den t.ex. är "Coins: 3")
		local red = (  math.floor((current_coins / 3) + 0.5)) -- Lägg till 0.5 och ta golvet
		local minCoinLos = 5

		if red < minCoinLos then -- Förlorar minimum 10 coins
			red = minCoinLos
		end

		local new_coins = current_coins - red
		local new_text = "Coins: "
		if new_coins >= 0 then

			--print(current_coins .."  - ".. red .. "  =  " ..new_coins )

			-- Uppdatera texten i labeln med det nya värdet
			new_text = new_text .. tostring(new_coins)

		else 

			playerTimesHit = playerTimesHit + 1
			new_text = new_text .. "0"
			UpdateLivesLable(self)
			
			
			
		end
		label.set_text("/text_holder#Coins", new_text)
		if (playerStartingLives - playerTimesHit) <= 0 then
			-- Die and restart
			playerIsDead = true
			gameActive = false
			msg.post(player, "playerDie")
			local text_url = msg.url("/text_holder#GameOver") -- URL till textkomponenten
			go.set(text_url, "color.w", 1) -- Sätter alfa (w) till 1 för att göra den synlig

		end
	
	end

	if gamemode == "Timed" then
		playerTimesHit = playerTimesHit + 1
		timeToCollectLeft = timeToCollectLeft - dmgTimeLosPenelty
		UpdateLivesLable(self)
		
	end
		
	
end

function UpdateLivesLable(self)
	if gamemode == "Timed" then
		
		label.set_text("/text_holder#Lives", "Times hit: "..playerTimesHit )

	elseif gamemode == "Endless" then
		label.set_text("/text_holder#Lives", "Lives: ".. (playerStartingLives - playerTimesHit))
	end


end
function UpdateTimmer(self)
	if gamemode == "Endless" then
		print("TTTTTT eeeeee")
		label.set_text("/text_holder#Timer", "Time: "..math.floor(gameTime + 0.5))
	elseif gamemode == "Timed" then
		print("TTTTTT tttttttt")
		label.set_text("/text_holder#Timer", "Time: "..math.floor(timeToCollectLeft + 0.5))
	end
	
end
	
function StartGame(self)
	gameActive = true
	label.set_text("/text_holder#Coins", "Coins: 0")
	ApplyDifficulty(self)
	player = factory.create("/game_maneger#player_factory", vmath.vector3(100, level_heights[1], 0),nil, {}, 0.2)
	msg.post(player, "set_level_heights", { heights = level_heights })
	msg.post(player, "set_starting_lives", { lives = playerStartingLives })
	-- Bygg URL för spinemodellen
	local spinemodel_url = msg.url(player) -- Skapar en bas-URL från instans-ID:t
	spinemodel_url.fragment = "spinemodel" -- Lägg till komponentnamnet
	msg.post(player, "spineURL", { spineURL = spinemodel_url })
	UpdateLivesLable(self)
end

function ApplyDifficulty(self)
	if difficulty == "Hard" then
		print("HARRRRRD")
		spikeSpawnExponentialIncrease = spikeSpawnExponentialIncrease * 10
		playerStartingLives = playerStartingLives - 1
		

		if gamemode == "Endless" then
			print("Apply endless")
			coin_spawn_interval = coin_spawn_interval * 5
			dmgTimeLosPenelty = dmgTimeLosPenelty * 2
		end
		
	end

end

function on_message(self, message_id, message, sender)
	if message_id == hash("mainMenuInput") then
		gamemode = message.gamemode
		difficulty = message.difficulty
		StartGame(self)
	end
	if message_id == hash("playerDamaged") then
		if gamemode == "Timed" then
			print("Penanlty")
			timeToCollectLeft = timeToCollectLeft - dmgTimeLosPenelty
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("key1") then
		if action.pressed then
			
			--msg.post("#", "StartGame", {})
		end
	end
end
